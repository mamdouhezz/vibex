{
    "schemaVersion": "1.0.0",
    "ruleSetName": "VibeX Unidirectional Dependency Architecture Rules",
    "version": "1.0.0",
    "description": "Rules enforcing a strict unidirectional dependency flow to prevent circular imports and maintain architectural clarity.",
    "enforcedBy": "VibeX AI Software Architect",
    "philosophy": "Data and imports must flow one way only. Any violation signals an architectural problem that must be fixed at the design level, not hacked around.",
  
    "rules": [
      {
        "ruleId": "DEP-01",
        "name": "Pages Import Rules",
        "description": "Pages are the top-level entry points. They cannot depend on other pages.",
        "can_import_from": ["components", "hooks", "engine", "utils", "types", "constants"],
        "cannot_import_from": ["pages"]
      },
      {
        "ruleId": "DEP-02",
        "name": "Components Import Rules",
        "description": "Components may only depend on smaller UI primitives, hooks, engine, utils, types, and constants.",
        "can_import_from": ["components (UI primitives only)", "hooks", "engine", "utils", "types", "constants"],
        "cannot_import_from": ["pages"]
      },
      {
        "ruleId": "DEP-03",
        "name": "Engine, Hooks & Utils Import Rules",
        "description": "Engine logic, hooks, and utils form the low-level foundation. They cannot depend upwards.",
        "can_import_from": ["types", "constants", "utils"],
        "cannot_import_from": ["pages", "components", "engine (cross-import restricted)", "hooks (cross-import restricted)"]
      },
      {
        "ruleId": "DEP-04",
        "name": "Types & Constants Rules",
        "description": "Types and constants are the absolute foundation of the system. They must never import anything outside themselves.",
        "can_import_from": ["types (self-contained only)"],
        "cannot_import_from": ["pages", "components", "engine", "hooks", "utils"]
      }
    ],
  
    "implementationProtocol": {
      "title": "Unidirectional Dependency Protocol",
      "steps": [
        {
          "step": 1,
          "name": "Verify Before Import",
          "action": "Before writing any import, confirm it respects the downward dependency flow."
        },
        {
          "step": 2,
          "name": "Detect Violations",
          "action": "If an import violates the rules, stop and reassess the design. Do not force the import."
        },
        {
          "step": 3,
          "name": "Refactor Instead of Breaking Rules",
          "action": "Use one of the three solutions: move shared logic down, lift state up, or create a new foundational file."
        },
        {
          "step": 4,
          "name": "Run Dependency Audit",
          "action": "Periodically map the import graph to detect hidden cycles. Any cycle is a build blocker."
        }
      ]
    },
  
    "approved_solutions": {
      "move_logic_down": "If two files at different levels need the same logic, move it to utils/types/constants.",
      "lift_state_up": "If a component needs parent data, pass it as props instead of importing.",
      "new_foundation_file": "If shared constants/types cause dependency loops, create a new file under types/ or constants/."
    }
  }