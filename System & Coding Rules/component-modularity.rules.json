{
    "schemaVersion": "1.0.0",
    "ruleSetName": "VibeX Component Modularity & Single Responsibility Mandate",
    "version": "1.0.0",
    "description": "Architectural rules enforcing modular, single-responsibility React components, preventing monolithic 'God Components'.",
    "enforcedBy": "VibeX AI Staff Engineer during code generation and review.",
    "philosophy": "A component should do one thing and do it well. If it does too much, it must be decomposed.",
    
    "rules": [
      {
        "ruleId": "SRP-01",
        "name": "Single Responsibility Principle (SRP) for Components",
        "description": "Every component must have a single, well-defined responsibility. It should either handle UI presentation, state logic, or data fetching — but not all at once.",
        "guidelines": [
          "If a component fetches data AND renders a complex list, split it into a container (fetching) and a presentational (rendering) component.",
          "A component’s name must clearly describe its purpose (e.g., `UserProfileCard` vs. bad: `UserStuff`)."
        ]
      },
      {
        "ruleId": "MOD-02",
        "name": "Component Decomposition Mandate",
        "description": "Large components must be broken down into smaller, logical sub-components. This is mandatory, not optional.",
        "metrics": {
          "maxLinesOfCode": {
            "softLimit": 150,
            "hardLimit": 250,
            "action": "Exceeding 150 triggers refactoring review. Exceeding 250 = build failure."
          },
          "maxResponsibilities": {
            "limit": 1,
            "examples": ["Rendering a form section", "Managing a piece of state", "Displaying a chart"]
          },
          "maxUseEffectHooks": {
            "limit": 3,
            "action": "More than 3 useEffect hooks = strong sign of too many responsibilities → must be refactored."
          }
        },
        "guidelines": [
          "If a JSX block has repeated logic, extract it into a sub-component.",
          "Use dedicated folders for parent + children components. Example: `src/components/MediaPlan/MediaPlan.tsx`, `MediaPlanHeader.tsx`, `MediaPlanRow.tsx`."
        ]
      },
      {
        "ruleId": "STR-03",
        "name": "Clear Prop-Driven Communication",
        "description": "Components should communicate via props (down) and callbacks (up). Avoid overusing context or global state unless necessary.",
        "guidelines": [
          "Favor composition over complex conditional rendering inside a single component.",
          "Pass data/state down as props. Pass events (e.g., onSubmit, onClick) up via callbacks."
        ]
      },
      {
        "ruleId": "HOOK-04",
        "name": "Logic Abstraction with Custom Hooks",
        "description": "Complex logic must be abstracted out of components into reusable custom hooks.",
        "guidelines": [
          "If a component has heavy useState/useEffect logic, extract into a custom hook (e.g., `useTheme`, `useExportHistory`).",
          "Keep the component body clean and focused on rendering JSX."
        ]
      }
    ],
  
    "implementationProtocol": {
      "title": "Protocol for Applying Modularity Rules",
      "steps": [
        {
          "step": 1,
          "action": "Analyze the Blueprint",
          "description": "Before building a component, check its expected size and responsibilities."
        },
        {
          "step": 2,
          "action": "Identify Decomposition Candidates",
          "description": "Spot sections that can be sub-components (e.g., form section, list item, header)."
        },
        {
          "step": 3,
          "action": "Create the Component Structure",
          "description": "Create a folder for the component with parent and sub-files organized."
        },
        {
          "step": 4,
          "action": "Implement Sub-Components First",
          "description": "Sub-components should be reusable and dumb (props in, callbacks out)."
        },
        {
          "step": 5,
          "action": "Compose the Parent Component",
          "description": "Parent manages state and composes sub-components."
        },
        {
          "step": 6,
          "action": "Final Review",
          "description": "Check metrics (line count, useEffect, responsibilities). Must comply before merging."
        }
      ]
    }
  }